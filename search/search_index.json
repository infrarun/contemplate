{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Contemplate","text":"<p>Contemplate is a template rendering tool designed to render configuration templates. While it takes inspiration from configuration management systems such as ansible's template action, it is specifically not designed to be a full configuration management system. Furthermore, it's designed to be run on the target system, and ships as a single static binary.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Template language based on jinja2</li> <li>Layered data sources: File, Environment Variables, Kubernetes ConfigMaps and Secrets</li> <li>Live re-rendering of templates when data changes</li> <li>Notification of configuration changes for downstream daemons</li> <li>Builds as a static binary for use in distroless or scratch containers</li> </ul>"},{"location":"#usage-in-containers","title":"Usage in Containers","text":"<p>To add Contemplate to a container build, add the following build step to your <code>Dockerfile</code>:</p> <pre><code>COPY --from=ghcr.io/infrarun/contemplate:latest /contemplate /contemplate\n</code></pre>"},{"location":"advanced/debugging/","title":"Debugging","text":""},{"location":"advanced/debugging/#increasing-verbosity","title":"Increasing Verbosity","text":"<p>The verbosity of <code>contemplate</code> can be increased by specifying <code>-v</code> (debug output) or <code>-vv</code> (trace output). Changes to rendered templates can be written to stderr by specifying the <code>--diff</code> option, while the <code>--dry-run</code>/<code>-n</code> command-line option will suppress the rendered template to be written.</p>"},{"location":"advanced/debugging/#templates","title":"Templates","text":"<p>A list of all available filters can be dumped using the <code>debug()</code> built-in: <pre><code>echo \"{{ debug() }}\" | contemplate\n</code></pre></p>"},{"location":"advanced/integration/","title":"Integrating with Other Software","text":"<p>Apart from rendering configuration, Contemplate has features to ensure the consumers of the configuration are only started once rendering is complete, as well as notifying them of configuration changes.</p>"},{"location":"advanced/integration/#live-reloading","title":"Live Reloading","text":"<p>When underlying data sources change, the configuration is re-rendered if the <code>--watch</code> command-line option is specified:</p> <pre><code>export CONTEMPLATE_DATASOURCES=\"...\"\ncontemplate --watch\n</code></pre> <p>Note</p> <p>Watch mode is not supported when standard output is specified, since it does not support re-winding and re-rendering. Furthermore, at least one data source will need to support watch mode.</p> <p>Software that does not take care of its own configuration file reloading will need to be notified of this change. Contemplate supports this using either signals or a custom reload hook.</p>"},{"location":"advanced/integration/#signaling","title":"Signaling","text":"<p>The <code>--on-reload-signal</code> argument takes two arguments: the signal to send, and the target process. Signals can be specified both using their number or their name (i.e. the following would be equivalent: <code>SIGINT</code>, <code>INT</code>, <code>2</code>). The target process can be identified either using its name or its PID.  If a name is specified, all processes containing the specified name are signaled.</p> <pre><code>contemplate \\\n    --watch \\\n    --file file.yml \\\n    --template config.template nginx.conf \\\n    --on-reload-signal HUP nginx\n</code></pre>"},{"location":"advanced/integration/#reload-hook","title":"Reload Hook","text":"<p>If signaling is not sufficient to notify downstream software that the configuration has changed, a custom reload hook can be executed on reload. This is specified using the <code>--on-reload-command</code>/<code>-r</code> or <code>--on-reload-execute</code>/<code>-R</code> command-line options. The difference between these two options is that <code>--on-reload-command</code> requires the presence of a shell interpreter, and takes a single string argument that is executed as a shell command, while <code>--on-reload-exec</code> takes a path to an executable. When executed, the <code>CONTEMPLATED_FILES</code> environment variable will be set to a comma-separated list of the changed files.</p> <pre><code>contemplate \\\n    --watch \\\n    --file data.yml \\\n    --template config.template /etc/postfix/main.cf \\\n    --on-reload-command \"postfix reload\"\n</code></pre> <p>Note</p> <p>When underlying data sources change rapidly, changes can be debounced by the on-reload hook by sleeping before notifying the target process. The on-reload hook will be terminated with the <code>SIGINT</code> signal before a new hook is executed. Implementors relying on this feature in combination with the <code>CONTEMPLATED_FILES</code> variable will need to account for previous values of <code>CONTEMPLATED_FILES</code> as well as inherent raciness.</p>"},{"location":"advanced/integration/#waiting-for-rendering-to-be-completed","title":"Waiting for Rendering to be Completed","text":"<p>Most software reads configuration files on startup. Therefore, contemplate needs to be finished rendering configuration files by the time the software using it is started. This can be achieved using the <code>--and-then-exec</code> / <code>-x</code> command-line option, which allows an executable to be run once rendering is completed. All following arguments will be passed on, up to a delimiting argument containing just a semi-colon (<code>;</code>).</p> <pre><code>contemplate \\\n  --template config.template app.cfg \\\n  -x /usr/bin/app -h 0.0.0.0 -p 8080 \\;\n  # any further args after \\; go to contemplate\n</code></pre> <p>In cases where Contemplate will need to continue running, such as when doing live re-loading, it will fork itself and continue running in the child after the initial render. The parent will execute the target program.</p> <p>Note</p> <p>On linux, Contemplate will register a death signal before executing the target process, ensuring that the child is terminated when the target process is terminated. This is important for clean shutdown behavior in containerized environments. When Contemplate is used with <code>--and-then-exec</code> as the container's entrypoint, after rendering, the target process will be PID 1 in the container.</p>"},{"location":"data_sources/environment/","title":"Taking Data From The Environment","text":"<p>Environment variables are specified as a data source using the <code>--env</code> / <code>-e</code> command-line argument or the <code>env</code> prefix in the <code>CONTEMPLATE_DATASOURCES</code> environment variable:</p> Command-LineEnvironment <pre><code>contemplate --env\n</code></pre> <pre><code>env CONTEMPLATE_DATASOURCES=\"env\" contemplate\n</code></pre> <p>Since the environment variables of the contemplate process cannot be changed during runtime, environment data sources do not support live-reloading.</p> <p>Environment variable names are normalized.</p>"},{"location":"data_sources/environment/#prefix-filtering","title":"Prefix Filtering","text":"<p>An optional prefix can be specified on the command-line or in the <code>CONTEMPLATE_DATASOURCES</code> environment variable. In this case, only environment values with that prefix are considered by contemplate, and the prefix is dropped from the name.</p> <p>In the following example, only the environment variables <code>FOO_BAR</code> and <code>FOO_BAZ</code> will be considered, while <code>QUX</code> will be ignored:</p> Command-LineEnvironment <pre><code>env FOO_BAR=1 FOO_BAZ=2, QUX=3 contemplate --env=FOO\n</code></pre> <pre><code>env CONTEMPLATE_DATASOURCES=\"env:FOO\" FOO_BAR=1 FOO_BAZ=2, QUX=3 contemplate\n</code></pre> <p>After processing, the context will contain the following values, since the prefix is dropped: <pre><code>{\n    \"bar\": 1,\n    \"baz\": 2\n}\n</code></pre></p>"},{"location":"data_sources/environment/#structured-values","title":"Structured Values","text":"<p>Environment variables can only store strings. However, Contemplate will parse the values of environment variables, and construct more complex values where appropriate.</p> <ul> <li>Booleans: <code>true</code> and <code>false</code> (case sensitive!) will be converted to their corresponding boolean values.</li> <li>Numbers: Any value that contains only digits, and optionally a single decimal separator (<code>.</code>) and/or a <code>-</code> sign prefix, will be parsed as a number, e.g.: <code>NUMBER=1.1</code>.</li> <li>Lists: Comma-separated values, delimited by <code>[</code> and <code>]</code>, will be parsed as a list, e.g.: <code>VALUES=[1.0, 3, true]</code>.</li> <li>Dictionaries: Comma-separated key-value pairs, separated by <code>=</code> and delimited by <code>{</code> and <code>}</code> will be parsed as a dictionary, e.g.: <code>COLOR={red=20, green=30, blue=10}</code>.</li> </ul> <p>In ambiguous cases, interpretation as a string can be enforced using double quotes (<code>\"</code>). For more information, including details on escaping, please refer to the figment documentation.</p>"},{"location":"data_sources/file/","title":"File Data Sources","text":"<p>Files are among the simplest data sources. The following file types are supported:</p> <ul> <li>YAML (including merge support)</li> <li>TOML</li> <li>JSON</li> </ul> <p>Files are identified by Contemplate using their file extension, and specified using the <code>--file</code> / <code>-f</code> command-line argument or the <code>file</code> prefix in the <code>CONTEMPLATE_DATASOURCES</code> environment variable</p> Command-LineEnvironment <pre><code>contemplate --file data.yml --file data.toml --file data.json\n</code></pre> <pre><code>env CONTEMPLATE_DATASOURCES=\"file:data.yml,file:data.toml,file:data.json\" contemplate\n</code></pre> <p>File data sources support live-reloading. When a file is changed, it will cause a re-render of the templates.</p>"},{"location":"data_sources/kubernetes/","title":"Kubernetes Data Sources","text":"<p>Contemplate can take values from Kubernetes ConfigMap and Secret resources. These can be specified using the <code>--k8s-configmap</code> / <code>--k8s-secret</code> command-line argument or the <code>k8s-configmap</code>/<code>k8s-secret</code> prefix in the <code>CONTEMPLATE_DATASOURCES</code> environment variable:</p> Command-LineEnvironment <pre><code>contemplate --k8s-configmap app-config --k8s-secret app-secret\n</code></pre> <pre><code>env CONTEMPLATE_DATASOURCES=\"k8s-configmap:app-config,k8s-secret:app-secret\" contemplate\n</code></pre> <p>The Kubernetes context and namespace are taken from the user's <code>KUBECONFIG</code> environment variable or <code>~/.kube/config</code>, or, if that failed, the in-cluster configuration (<code>KUBERNETES_SERVICE_HOST</code>, <code>KUBERNETES_SERVICE_PORT</code> and service account token in <code>/var/run/secrets/kubernetes.io/serviceaccount/</code>).</p> <p>The namespace can be overridden using the <code>--k8s-namespace</code> command-line argument.</p> <p>Keys in Kubernetes ConfigMaps and Secrets are normalized.</p>"},{"location":"data_sources/overview/","title":"Data Sources","text":"<p>Data sources provide the context for the template engine, i.e. the values to be inserted into the template. To allow a flexible but structured way for values to have defaults, be overridden, or customizable at runtime, contemplate can use multiple data sources at the same time. Each data source can add new values or override previous ones -- the context used by the template engine is the stacked view of all specified data sources. Contemplate makes use of a framework named figment for this purpose.</p>"},{"location":"data_sources/overview/#command-line-arguments","title":"Command-Line Arguments","text":"<p>Data sources can be specified using command-line arguments, and are evaluated in order, left to right, with later specifications overriding earlier ones.</p> <p>For example, in the following invocation, values will be taken from the file <code>data.yml</code>, and environment variables can override these: <pre><code>contemplate --file data.yml --env\n</code></pre></p>"},{"location":"data_sources/overview/#the-contemplate_datasources-environment-variable","title":"The <code>CONTEMPLATE_DATASOURCES</code> Environment Variable","text":"<p>Data sources can furthermore be specified using the <code>CONTEMPLATE_DATASOURCES</code> environment variable. This should contain a comma-separated list of data source specifications, each of which is of the form <code>&lt;type&gt;[:&lt;argument&gt;]</code>:</p> <pre><code>env CONTEMPLATE_DATASOURCES=\"file:data.yml,env\" contemplate\n</code></pre> <p>Data sources specified in the <code>CONTEMPLATE_DATASOURCES</code> environment variable are evaluated in order left-to-right, just like command-line arguments. However, they can be overridden using command-line arguments.</p> <p>In the following example, values specified in <code>defaults.yml</code> will be overridden by values in <code>overrides.yml</code>:</p> <pre><code>env CONTEMPLATE_DATASOURCES=\"file:defaults.yml\" contemplate --file overrides.yml\n</code></pre>"},{"location":"data_sources/overview/#data-normalization","title":"Data Normalization","text":"<p>Many data sources, e.g. files, support specifying values in a nested-tree format:</p> data.ymldata.jsondata.toml <pre><code>name: Alice\nage: 23\npet:\n  animal: dog\n  name: Bob\n</code></pre> <pre><code>{\n  \"name\": \"Alice\",\n  \"age\": 23,\n  \"pet\": {\n    \"animal\": \"dog\",\n    \"name\": \"Bob\"\n  }\n}\n</code></pre> <pre><code>name = \"Alice\"\nage = 23\n\n[pet]\nanimal = \"dog\"\nname = \"Bob\"\n</code></pre> <p>Others, such as environment variables, only allow key-value pairs, and are conventionally specified in all-caps: <pre><code>NAME=\"Alice\"\nAGE=23\nPET_NAME=\"Bob\"\nPET_ANIMAL=\"dog\"\n</code></pre></p> <p>To bridge this gap, Contemplate will parse the variable names and construct a nested dictionary using the following rules:</p> <ul> <li>Underscores (<code>_</code>) symbolize descent into a nested dictionary</li> <li>Variable names are converted to lower-case</li> </ul>"},{"location":"getting_started/overview/","title":"Overview","text":""},{"location":"getting_started/overview/#concepts","title":"Concepts","text":""},{"location":"templates/filters/","title":"Filters","text":"<p>The following filters were added to Contemplate. For a full list of filters, see the output of the <code>debug()</code> function:</p> <pre><code>echo \"{{ debug().env.filters }}\" | contemplate\n</code></pre>"},{"location":"templates/filters/#base64encode","title":"base64encode","text":"<p>This base64-encodes a string or a list of bytes, returning a base64 encoded string.</p> <p>Example:</p> TemplateRendered <pre><code>{{ \"Hello\" | base64encode }}\n{{ [0,0,0,0] | base64encode }}\n</code></pre> <pre><code>SGVsbG8=\nAAAAAA==\n</code></pre>"},{"location":"templates/filters/#hexencode","title":"hexencode","text":"<p>This hex-encodes a string or a list of bytes, returning a base64 encoded string.</p> <p>Example:</p> TemplateRendered <pre><code>{{ \"Hello\" | hexencode }}\n{{ [0,0,0,0] | hexencode }}\n</code></pre> <pre><code>48656c6c6f\n00000000\n</code></pre>"},{"location":"templates/filters/#from_json","title":"from_json","text":"<p>Constructs an object from a JSON string.</p> <p>Example:</p> TemplateRendered <pre><code>The color is {{ ('{\"color\": \"green\"}' | from_json).color }}\n</code></pre> <pre><code>The color is green\n</code></pre>"},{"location":"templates/filters/#from_toml","title":"from_toml","text":"<p>Constructs an object from a TOML string.</p> <p>Example:</p> TemplateRendered <pre><code>The color is {{ ('color=\"orange\"' | from_toml).color }}\n</code></pre> <pre><code>The color is orange\n</code></pre>"},{"location":"templates/filters/#from_yaml","title":"from_yaml","text":"<p>Constructs an object from a YAML string.</p> <p>Example:</p> TemplateRendered <pre><code>The color is {{ ('color: purple' | from_yaml).color }}\n</code></pre> <pre><code>The color is purple\n</code></pre>"},{"location":"templates/overview/","title":"Templates","text":"<p>Templates are content written in <code>minijinja</code>, a templating language close to <code>jinja2</code>.</p>"},{"location":"templates/overview/#standard-in-output","title":"Standard In-/Output","text":"<p>By default, Contemplate will read a template on standard input, and write to standard output:</p> <pre><code>$ export NAME=\"Alice\"\n$ echo 'Hello, I am {{ name }}!' | contemplate -q --env\nHello, I am Alice!\n$\n</code></pre> <p>Note</p> <p>A log message will be printed when reading from standard input, prompting the user to enter a template. This is suppressed in the above example using <code>-q</code>.</p> <p>The output can be directed to a file by specifying it using <code>--output</code>/<code>-o</code>:</p> <pre><code>$ export NAME=\"Bob\"\n$ echo 'Hello, I am {{ name }}!' | contemplate --env -q -o output.txt\n$ cat output.txt\nHello, I am Bob!\n$\n</code></pre> <p>An input file can be specified as a positional argument:</p> <pre><code>$ export NAME=\"Charlie\"\n$ echo 'Hello, I am {{ name }}!' &gt; template.txt\n$ contemplate --env template.txt\nHello, I am Charlie!\n$\n</code></pre>"},{"location":"templates/overview/#in-place-rendering","title":"In-Place Rendering","text":"<p>If the source and target file are identical, in-place rendering can be used. This is enabled using the <code>--in-place</code>/<code>-i</code> command-line parameter. When enabled, multiple templates can be specified as positional arguments, each of which will be overwritten with the rendered context:</p> <pre><code>contemplate -i template1 template2\n</code></pre> <p>A backup of the original template can be automatically made by specifying a backup extension. The following will back-up the templates as <code>template1.bak</code> and <code>template2.bak</code>:</p> <pre><code>contemplate --in-place=bak template1 template2\n</code></pre> <p>Note</p> <p>To prevent backups from being overwritten by repeat invocations of Contemplate, it will refuse to overwrite backups.</p>"},{"location":"templates/overview/#multiple-templates","title":"Multiple templates","text":"<p>Multiple templates can be specified on the command line with the <code>--template</code> / <code>-t</code> argument. Each <code>--template</code> argument takes two parameters, the input and output parameter. The following example renders the template contained in <code>input1.txt</code> to <code>output1.txt</code>, and the template contained in <code>input2.txt</code> to <code>output2.txt</code>.</p> <pre><code>contemplate \\\n  --template input1.txt output1.txt \\\n  --template input2.txt output2.txt\n</code></pre> <p>Note</p> <p>The output specification is optional. If left unspecified, output is directed to standard output. To specify standard input or standard output explicitly, <code>-</code> can be passed as a name, e.g. <code>--template - -</code> will cause Contemplate to read a template from standard input and write to standard output. However, it is an error to specify standard input as multiple source or destination values.</p>"}]}